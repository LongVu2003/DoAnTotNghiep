// Testbench for complex_matrix_mul module
// Reads matrix data from files generated by Matlab script
// Converts floating-point data to fixed-point (Q8.8)
// Compares DUT output with a golden reference
`timescale 1ns/1ps

module tb_complex_matrix_mul;
    // Parameters
    localparam N = 16;
    localparam Q = 8;
    localparam FBITS = N - Q; // Fractional bits = 8
    localparam CM_LATENCY = 5;

    // DUT I/O signals
    reg clk;
    reg rst;
    reg start;
    reg signed [32*N-1:0] H_in_flat;
    reg signed [16*N-1:0] S_in_flat;
    wire signed [16*N-1:0] Sq_out_flat;
    wire done;

    // Testbench specific variables
    integer i, j, k;
    integer H_file, S_file, Hq_file;
    real H_float_re [0:3][0:3];
    real H_float_im [0:3][0:3];
    real S_float_re [0:3][0:1];
    real S_float_im [0:3][0:1];
    real Hq_float_re_ref [0:3][0:1];
    real Hq_float_im_ref [0:3][0:1];

    // DUT instantiation
    complex_matrix_mul #(
        .Q(Q),
        .N(N),
        .CM_LATENCY(CM_LATENCY)
    ) dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .H_in_flat(H_in_flat),
        .S_in_flat(S_in_flat),
        .Sq_out_flat(Sq_out_flat),
        .done(done)
    );

    // Clock generation
    initial begin
        clk = 0;
        forever #5 clk = ~clk; // 10 ns period
    end

    // Test sequence
    initial begin
        // Open data files
        H_file = $fopen("SM_OSTBC_RayleighChannel_4Rx4Tx.dat", "r");
        S_file = $fopen("SM_OSTBC_Tx_SC_Codewords_4Tx2Symbol_Periods.dat", "r");
        Hq_file = $fopen("SM_OSTBC_H_S_Product_4x2.dat", "r");

        if (!H_file || !S_file || !Hq_file) begin
            $display("ERROR: Could not open one or more data files. Please run the modified Matlab script first.");
            $finish;
        end

        // Reset DUT
        $display("--------------------------------------------------");
        $display("Starting simulation...");
        rst = 1;
        start = 0;
        #20;
        rst = 0;
        
        $display("Entering main test loop...");
        
        for (integer test_num = 0; test_num < 100; test_num = test_num + 1) begin
            // Read next test vector from files
            // Read H matrix (4x4)
            for (i = 0; i < 4; i = i + 1) begin
                for (j = 0; j < 4; j = j + 1) begin
                    if ($fscanf(H_file, "%f", H_float_re[i][j]) == 0) $finish;
                end
            end
            for (i = 0; i < 4; i = i + 1) begin
                for (j = 0; j < 4; j = j + 1) begin
                    if ($fscanf(H_file, "%f", H_float_im[i][j]) == 0) $finish;
                end
            end

            // Read S matrix (4x2)
            for (i = 0; i < 4; i = i + 1) begin
                for (j = 0; j < 2; j = j + 1) begin
                    if ($fscanf(S_file, "%f", S_float_re[i][j]) == 0) $finish;
                end
            end
            for (i = 0; i < 4; i = i + 1) begin
                for (j = 0; j < 2; j = j + 1) begin
                    if ($fscanf(S_file, "%f", S_float_im[i][j]) == 0) $finish;
                end
            end

            // Read Hq golden reference (4x2)
            for (i = 0; i < 4; i = i + 1) begin
                for (j = 0; j < 2; j = j + 1) begin
                    if ($fscanf(Hq_file, "%f", Hq_float_re_ref[i][j]) == 0) $finish;
                end
            end
            for (i = 0; i < 4; i = i + 1) begin
                for (j = 0; j < 2; j = j + 1) begin
                    if ($fscanf(Hq_file, "%f", Hq_float_im_ref[i][j]) == 0) $finish;
                end
            end
            
            // Convert and pack H and S to fixed-point format
            H_in_flat = 0;
            S_in_flat = 0;
            for (i = 0; i < 4; i = i + 1) begin
                for (j = 0; j < 4; j = j + 1) begin
                    integer h_re_fix = $rtoi(H_float_re[i][j] * (2**FBITS));
                    integer h_im_fix = $rtoi(H_float_im[i][j] * (2**FBITS));
                    H_in_flat[((i*4 + j)*2 + 0)*N +: N] = h_re_fix;
                    H_in_flat[((i*4 + j)*2 + 1)*N +: N] = h_im_fix;
                end
            end
            for (i = 0; i < 4; i = i + 1) begin
                for (j = 0; j < 2; j = j + 1) begin
                    integer s_re_fix = $rtoi(S_float_re[i][j] * (2**FBITS));
                    integer s_im_fix = $rtoi(S_float_im[i][j] * (2**FBITS));
                    S_in_flat[((i*2 + j)*2 + 0)*N +: N] = s_re_fix;
                    S_in_flat[((i*2 + j)*2 + 1)*N +: N] = s_im_fix;
                end
            end

            // Trigger DUT
            start = 1;
            @(posedge clk);
            start = 0;
            
            // Wait for done signal
            @(posedge done);
            
            // Check results
            $display("--------------------------------------------------");
            $display("Test case %d completed.", test_num + 1);
            
            integer pass_count = 0;
            integer fail_count = 0;
            real tolerance = 0.01; // Tolerance for floating point comparison
            
            for (i = 0; i < 4; i = i + 1) begin
                for (j = 0; j < 2; j = j + 1) begin
                    // Unpack real and imaginary parts from DUT output
                    integer sq_re_dut = Sq_out_flat[((i*2 + j)*2 + 0)*N +: N];
                    integer sq_im_dut = Sq_out_flat[((i*2 + j)*2 + 1)*N +: N];

                    // Convert DUT result back to float for comparison
                    real sq_re_dut_float = sq_re_dut / (2.0**FBITS);
                    real sq_im_dut_float = sq_im_dut / (2.0**FBITS);

                    // Check real part
                    if ($abs(sq_re_dut_float - Hq_float_re_ref[i][j]) < tolerance) begin
                        pass_count++;
                    end else begin
                        $display("FAIL: Output[real][%d][%d] mismatch. DUT: %f, Ref: %f", i, j, sq_re_dut_float, Hq_float_re_ref[i][j]);
                        fail_count++;
                    end
                    
                    // Check imaginary part
                    if ($abs(sq_im_dut_float - Hq_float_im_ref[i][j]) < tolerance) begin
                        pass_count++;
                    end else begin
                        $display("FAIL: Output[imag][%d][%d] mismatch. DUT: %f, Ref: %f", i, j, sq_im_dut_float, Hq_float_im_ref[i][j]);
                        fail_count++;
                    end
                end
            end
            
            if (fail_count == 0) begin
                $display("Test case %d PASSED.", test_num + 1);
            end else begin
                $display("Test case %d FAILED with %d mismatches.", test_num + 1, fail_count);
            end
        end
        
        $display("--------------------------------------------------");
        $display("Simulation finished.");
        $fclose(H_file);
        $fclose(S_file);
        $fclose(Hq_file);
        $finish;
    end
endmodule

